package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"slices"
	"sort"

	"github.com/toba/jig/internal/todo/config"
	"github.com/toba/jig/internal/todo/core"
	"github.com/toba/jig/internal/todo/graph/model"
	"github.com/toba/jig/internal/todo/issue"
)

// Due is the resolver for the due field.
func (r *issueResolver) Due(ctx context.Context, obj *issue.Issue) (*string, error) {
	if obj.Due == nil {
		return nil, nil
	}
	s := obj.Due.String()
	return &s, nil
}

// Sync is the resolver for the sync field.
func (r *issueResolver) Sync(ctx context.Context, obj *issue.Issue) ([]*model.SyncEntry, error) {
	if len(obj.Sync) == 0 {
		return []*model.SyncEntry{}, nil
	}

	// Collect sync names and sort for deterministic output
	names := make([]string, 0, len(obj.Sync))
	for name := range obj.Sync {
		names = append(names, name)
	}
	sort.Strings(names)

	entries := make([]*model.SyncEntry, 0, len(obj.Sync))
	for _, name := range names {
		entries = append(entries, &model.SyncEntry{
			Name: name,
			Data: obj.Sync[name],
		})
	}
	return entries, nil
}

// ParentID is the resolver for the parentId field.
func (r *issueResolver) ParentID(ctx context.Context, obj *issue.Issue) (*string, error) {
	if obj.Parent == "" {
		return nil, nil
	}
	return &obj.Parent, nil
}

// BlockingIds is the resolver for the blockingIds field.
func (r *issueResolver) BlockingIds(ctx context.Context, obj *issue.Issue) ([]string, error) {
	return obj.Blocking, nil
}

// BlockedByIds is the resolver for the blockedByIds field.
func (r *issueResolver) BlockedByIds(ctx context.Context, obj *issue.Issue) ([]string, error) {
	return obj.BlockedBy, nil
}

// BlockedBy is the resolver for the blockedBy field.
func (r *issueResolver) BlockedBy(ctx context.Context, obj *issue.Issue, filter *model.IssueFilter) ([]*issue.Issue, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*issue.Issue
	for _, link := range incoming {
		if link.LinkType == issue.LinkTypeBlocking {
			result = append(result, link.FromIssue)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// Blocking is the resolver for the blocking field.
func (r *issueResolver) Blocking(ctx context.Context, obj *issue.Issue, filter *model.IssueFilter) ([]*issue.Issue, error) {
	var result []*issue.Issue
	for _, targetID := range obj.Blocking {
		// Filter out broken links
		if target, err := r.Core.Get(targetID); err == nil {
			result = append(result, target)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// Parent is the resolver for the parent field.
func (r *issueResolver) Parent(ctx context.Context, obj *issue.Issue) (*issue.Issue, error) {
	if obj.Parent == "" {
		return nil, nil
	}
	// Filter out broken links
	parent, err := r.Core.Get(obj.Parent)
	if errors.Is(err, core.ErrNotFound) {
		return nil, nil
	}
	return parent, err
}

// Children is the resolver for the children field.
func (r *issueResolver) Children(ctx context.Context, obj *issue.Issue, filter *model.IssueFilter) ([]*issue.Issue, error) {
	incoming := r.Core.FindIncomingLinks(obj.ID)
	var result []*issue.Issue
	for _, link := range incoming {
		if link.LinkType == issue.LinkTypeParent {
			result = append(result, link.FromIssue)
		}
	}
	return ApplyFilter(result, filter, r.Core), nil
}

// CreateIssue is the resolver for the createIssue field.
func (r *mutationResolver) CreateIssue(ctx context.Context, input model.CreateIssueInput) (*issue.Issue, error) {
	b := &issue.Issue{
		Slug:     issue.Slugify(input.Title),
		Title:    input.Title,
		Type:     config.TypeTask,
		Blocking: []string{},
	}

	// Optional fields with defaults documented in schema
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Body != nil {
		b.Body = *input.Body
	}
	if len(input.Tags) > 0 {
		b.Tags = input.Tags
	}
	if input.Due != nil && *input.Due != "" {
		due, err := issue.ParseDueDate(*input.Due)
		if err != nil {
			return nil, err
		}
		b.Due = due
	}

	// Handle parent (with validation)
	if input.Parent != nil && *input.Parent != "" {
		// Normalise short ID to full ID
		parentID, _ := r.Core.NormalizeID(*input.Parent)
		if err := r.Core.ValidateParent(b, parentID); err != nil {
			return nil, err
		}
		b.Parent = parentID
	}

	// Handle blocking (with validation)
	if len(input.Blocking) > 0 {
		// Normalise short IDs to full IDs
		normalizedBlocking := make([]string, len(input.Blocking))
		for i, id := range input.Blocking {
			normalizedBlocking[i], _ = r.Core.NormalizeID(id)
			// Verify target exists
			if _, err := r.Core.Get(normalizedBlocking[i]); err != nil {
				return nil, fmt.Errorf("target issue not found: %s", id)
			}
		}
		b.Blocking = normalizedBlocking
	}

	// Handle blocked_by (with cycle validation)
	if len(input.BlockedBy) > 0 {
		// Normalise short IDs to full IDs
		normalizedBlockedBy := make([]string, len(input.BlockedBy))
		for i, id := range input.BlockedBy {
			normalizedBlockedBy[i], _ = r.Core.NormalizeID(id)
			// Verify blocker exists
			if _, err := r.Core.Get(normalizedBlockedBy[i]); err != nil {
				return nil, fmt.Errorf("blocker issue not found: %s", id)
			}
		}
		// Check for cycles with blocking relationships
		// (new issue being blocked_by X means X→newIssue, check if newIssue→X exists via blocking)
		for _, blockerID := range normalizedBlockedBy {
			if slices.Contains(b.Blocking, blockerID) {
				return nil, fmt.Errorf("would create cycle: new issue both blocks and is blocked by %s", blockerID)
			}
		}
		b.BlockedBy = normalizedBlockedBy
	}

	if err := r.Core.Create(b); err != nil {
		return nil, err
	}

	return b, nil
}

// UpdateIssue is the resolver for the updateIssue field.
func (r *mutationResolver) UpdateIssue(ctx context.Context, id string, input model.UpdateIssueInput) (*issue.Issue, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	// Validate body and bodyMod are mutually exclusive
	if input.Body != nil && input.BodyMod != nil {
		return nil, errors.New("cannot specify both body and bodyMod")
	}

	// Validate tags and addTags/removeTags are mutually exclusive
	if input.Tags != nil && (input.AddTags != nil || input.RemoveTags != nil) {
		return nil, errors.New("cannot specify both tags and addTags/removeTags")
	}

	// Update fields if provided
	if input.Title != nil {
		b.Title = *input.Title
	}
	if input.Status != nil {
		b.Status = *input.Status
	}
	if input.Type != nil {
		b.Type = *input.Type
	}
	if input.Priority != nil {
		b.Priority = *input.Priority
	}
	if input.Due != nil {
		if *input.Due == "" {
			b.Due = nil
		} else {
			due, err := issue.ParseDueDate(*input.Due)
			if err != nil {
				return nil, err
			}
			b.Due = due
		}
	}
	if input.Body != nil {
		b.Body = *input.Body
	} else if input.BodyMod != nil {
		// Apply body modifications
		workingBody := b.Body

		// Apply replacements sequentially
		if input.BodyMod.Replace != nil {
			for i, replaceOp := range input.BodyMod.Replace {
				newBody, err := issue.ReplaceOnce(workingBody, replaceOp.Old, replaceOp.New)
				if err != nil {
					return nil, fmt.Errorf("replacement %d failed: %w", i, err)
				}
				workingBody = newBody
			}
		}

		// Apply append if provided
		if input.BodyMod.Append != nil && *input.BodyMod.Append != "" {
			workingBody = issue.AppendWithSeparator(workingBody, *input.BodyMod.Append)
		}

		b.Body = workingBody
	}
	// Handle tags
	if input.Tags != nil {
		b.Tags = input.Tags
	} else if input.AddTags != nil || input.RemoveTags != nil {
		// Build a set of current tags
		tagSet := make(map[string]bool)
		for _, tag := range b.Tags {
			tagSet[tag] = true
		}

		// Add new tags
		if input.AddTags != nil {
			for _, tag := range input.AddTags {
				tagSet[tag] = true
			}
		}

		// Remove tags
		if input.RemoveTags != nil {
			for _, tag := range input.RemoveTags {
				delete(tagSet, tag)
			}
		}

		// Convert back to slice
		newTags := make([]string, 0, len(tagSet))
		for tag := range tagSet {
			newTags = append(newTags, tag)
		}
		b.Tags = newTags
	}

	// Handle parent relationship
	if input.Parent != nil {
		if err := r.validateAndSetParent(b, *input.Parent); err != nil {
			return nil, err
		}
	}

	// Handle blocking relationships
	if input.AddBlocking != nil {
		if err := r.validateAndAddBlocking(b, input.AddBlocking); err != nil {
			return nil, err
		}
	}
	if input.RemoveBlocking != nil {
		r.removeBlockingRelationships(b, input.RemoveBlocking)
	}

	// Handle blocked-by relationships
	if input.AddBlockedBy != nil {
		if err := r.validateAndAddBlockedBy(b, input.AddBlockedBy); err != nil {
			return nil, err
		}
	}
	if input.RemoveBlockedBy != nil {
		r.removeBlockedByRelationships(b, input.RemoveBlockedBy)
	}

	// ETag validation now happens inside Update() under write lock
	if err := r.Core.Update(b, input.IfMatch); err != nil {
		return nil, err
	}

	return b, nil
}

// DeleteIssue is the resolver for the deleteIssue field.
func (r *mutationResolver) DeleteIssue(ctx context.Context, id string) (bool, error) {
	// Verify issue exists
	_, err := r.Core.Get(id)
	if err != nil {
		return false, err
	}

	// Remove incoming links first
	if _, err := r.Core.RemoveLinksTo(id); err != nil {
		return false, err
	}

	// Delete the issue
	if err := r.Core.Delete(id); err != nil {
		return false, err
	}

	return true, nil
}

// SetSyncData is the resolver for the setSyncData field.
func (r *mutationResolver) SetSyncData(ctx context.Context, id, name string, data map[string]any, ifMatch *string) (*issue.Issue, error) {
	if name == "" {
		return nil, errors.New("sync name cannot be empty")
	}

	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	b.SetSync(name, data)

	if err := r.Core.SaveSyncOnly(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// RemoveSyncData is the resolver for the removeSyncData field.
func (r *mutationResolver) RemoveSyncData(ctx context.Context, id, name string, ifMatch *string) (*issue.Issue, error) {
	b, err := r.Core.Get(id)
	if err != nil {
		return nil, err
	}

	b.RemoveSync(name)

	if err := r.Core.SaveSyncOnly(b, ifMatch); err != nil {
		return nil, err
	}
	return b, nil
}

// Issue is the resolver for the issue field.
func (r *queryResolver) Issue(ctx context.Context, id string) (*issue.Issue, error) {
	b, err := r.Core.Get(id)
	if errors.Is(err, core.ErrNotFound) {
		return nil, nil
	}
	return b, err
}

// Issues is the resolver for the issues field.
func (r *queryResolver) Issues(ctx context.Context, filter *model.IssueFilter) ([]*issue.Issue, error) {
	var issues []*issue.Issue

	// If search filter is provided, start with search results
	if filter != nil && filter.Search != nil && *filter.Search != "" {
		searchResults, err := r.Core.Search(*filter.Search)
		if err != nil {
			return nil, err
		}
		issues = searchResults
	} else {
		issues = r.Core.All()
	}

	return ApplyFilter(issues, filter, r.Core), nil
}

// Issue returns IssueResolver implementation.
func (r *Resolver) Issue() IssueResolver { return &issueResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type issueResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
